<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Overview: Standard library</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-bottom: 0.6em}
    DIV.SwissExamples {font-family: Arial, Helvetica, sans-serif; font-size: 90%; line-height: 122%; margin-left: 2.2em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.WideHanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 6.0em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.WideHanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<H1 Style='font-family: "Rockwell", "Times New Roman", Times, serif; font-size: 240%'><B><SPAN Style="color:rgb(0,0,153)">Rationale</SPAN> for <SPAN Style="color:rgb(0,153,51)">Ada 2012</SPAN></B></H1>
<DIV Class="Normal"><FONT SIZE="+1"><I><A HREF="Rat12-TTL.html">John Barnes</A></I></FONT></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="Rat12-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-0-3.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-1-3-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-1-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>1.3.6 Overview: Standard library</H1>
<div class="Normal">The main improvements in the standard library concern 
containers. But there are a number of other changes which will be described 
first.</div>
<div class="Normal" style="margin-bottom: 0.4em">In Ada 2005, additional 
versions of <SPAN Class="swiss">Index</SPAN> and <SPAN Class="swiss">Index_Non_Blank</SPAN> 
were added to the package <SPAN Class="swiss">Ada.Strings.Fixed</SPAN> 
with an additional parameter <SPAN Class="swiss">From</SPAN> indicating 
the start of the search. The same should have been done for <SPAN Class="swiss">Find_Token</SPAN>. 
So Ada 2012 adds <A NAME="I1124"></A></div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Find_Token(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source:&nbsp;<B>in</B>&nbsp;String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set:&nbsp;<B>in</B>&nbsp;Maps.Character_Set;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From:&nbsp;<B>in</B>&nbsp;Positive;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test:&nbsp;<B>in</B>&nbsp;Membership;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First:&nbsp;<B>out</B>&nbsp;Positive;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Last:&nbsp;<B>out</B>&nbsp;Natural);</div>
<div class="Normal">Similar versions are added for bounded and unbounded 
strings to the corresponding packages.</div>
<div class="Normal" style="margin-bottom: 0.4em">New child packages 
of <SPAN Class="swiss">Ada.Strings</SPAN> are added to provide conversions 
between strings, wide strings, or wide wide strings and UTF-8 or UTF-16 
encodings. They are <A NAME="I1125"></A><A NAME="I1126"></A></div>
<div class="WideHanging-Term"><SPAN Class="swiss">Ada.Strings.UTF_Encoding</SPAN> 
&ndash;</div><div class="WideHanging-Body"><br clear="left">
 declares a function <SPAN Class="swiss">Encoding</SPAN> to convert a 
<SPAN Class="swiss">String</SPAN> into types <SPAN Class="swiss">UTF_8</SPAN>, 
<SPAN Class="swiss">UTF_16BE</SPAN>, or <SPAN Class="swiss">UTF_16LE</SPAN> 
where BE and LE denote Big Endian and Little Endian respectively. <A NAME="I1127"></A><A NAME="I1128"></A></div>
<div class="WideHanging-Term"><SPAN Class="swiss">Ada.Strings.UTF_Encoding.Conversions</SPAN> 
&ndash;</div><div class="WideHanging-Body"><br clear="left">
declares five functions <SPAN Class="swiss">Convert</SPAN> between the 
UTF schemes. <A NAME="I1129"></A><A NAME="I1130"></A></div>
<div class="WideHanging-Term"><SPAN Class="swiss">Ada.Strings.UTF_Encoding.Strings</SPAN> 
&ndash;</div><div class="WideHanging-Body"><br clear="left">
 declares functions <SPAN Class="swiss">Encode</SPAN> and <SPAN Class="swiss">Decode</SPAN> 
between the type <SPAN Class="swiss">String</SPAN> and the UTF schemes. 
<A NAME="I1131"></A><A NAME="I1132"></A></div>
<div class="WideHanging-Term"><SPAN Class="swiss">Ada.Strings.UTF_Encoding.Wide_Strings</SPAN> 
&ndash;</div><div class="WideHanging-Body"><br clear="left">
 declares six similar functions for the type <SPAN Class="swiss">Wide_String</SPAN>. 
<A NAME="I1133"></A><A NAME="I1134"></A></div>
<div class="WideHanging-Term"><SPAN Class="swiss">Ada.Strings.UTF_Encoding.Wide_Wide_Strings</SPAN> 
&ndash;</div><div class="WideHanging-Body"><br clear="left">
 declares six similar functions for the type <SPAN Class="swiss">Wide_Wide_String</SPAN>. 
<A NAME="I1135"></A><A NAME="I1136"></A></div>
<div class="Normal">Further new packages are <SPAN Class="swiss">Ada.Wide_Characters.Handling</SPAN> 
and <SPAN Class="swiss">Ada.Wide_Wide_Characters.Handling</SPAN>. These 
provide classification functions such as <SPAN Class="swiss">Is_Letter</SPAN> 
and <SPAN Class="swiss">Is_Lower</SPAN> and conversion functions such 
as <SPAN Class="swiss">To_Lower</SPAN> for the types <SPAN Class="swiss">Wide_Character</SPAN> 
and <SPAN Class="swiss">Wide_Wide_Character</SPAN> in a similar way to 
the existing package <SPAN Class="swiss">Ada.Characters.Handling</SPAN> 
for the type <SPAN Class="swiss">Character</SPAN>. <A NAME="I1137"></A><A NAME="I1138"></A><A NAME="I1139"></A><A NAME="I1140"></A></div>
<div class="Normal">Experience with the package <SPAN Class="swiss">Ada.Directories</SPAN> 
added in Ada 2005 has revealed a few shortcomings. <A NAME="I1141"></A><A NAME="I1142"></A></div>
<div class="Normal" style="margin-bottom: 0.4em">One problem concerns 
case sensitivity. Unfortunately, common operating systems differ in their 
approach. To remedy this the following are added to <SPAN Class="swiss">Ada.Directories</SPAN></div>
<div class="SwissExamples"><B>type</B>&nbsp;Name_Case_Kind&nbsp;<B>is</B><BR>
&nbsp;(Unknown,&nbsp;Case_Sensitive,&nbsp;Case_Insensitive,&nbsp;Case_Preserving);</div>
<div class="SwissExamples"><B>function</B>&nbsp;Name_Case_Equivalence(Name:&nbsp;<B>in</B>&nbsp;String)&nbsp;<B>return</B>&nbsp;Name_Case_Kind;</div>
<div class="Normal">Calling <SPAN Class="swiss">Name_Case_Equivalence</SPAN> 
enables one to discover the situation for the operating system concerned.</div>
<div class="Normal">Another problem is that the basic approach in <SPAN Class="swiss">Ada.Directories</SPAN> 
is a bit simplistic and assumes that file names can always be subdivided 
into a directory name and a simple name. Thus the existing function <SPAN Class="swiss">Compose</SPAN> 
is</div>
<div class="SwissExamples"><B>function</B>&nbsp;Compose<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Containing_Directory:&nbsp;String&nbsp;:=&nbsp;&quot;&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name:&nbsp;String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extension:&nbsp;String&nbsp;:=&nbsp;&quot;&quot;)&nbsp;<B>return</B>&nbsp;String;</div>
<div class="Normal">and this requires that the <SPAN Class="swiss">Name</SPAN> 
is a simple name such as <SPAN Class="swiss">&quot;My_File&quot;</SPAN> 
with possibly an extension if one is not provided.</div>
<div class="Normal" style="margin-bottom: 0.4em">Accordingly, an optional 
child package is introduced, <SPAN Class="swiss">Ada.Directories.Hierarchical_File_Names</SPAN>, 
and this adds the concept of relative names and a new version of <SPAN Class="swiss">Compose</SPAN> 
whose second parameter is a relative name and various functions such 
as <SPAN Class="swiss">Is_Simple_Name</SPAN> and <SPAN Class="swiss">Is_Relative_Name</SPAN>. 
<A NAME="I1143"></A><A NAME="I1144"></A></div>
<div class="Normal">Programs often need information about where they 
are being used. This is commonly called the Locale. As an example, in 
some regions of the world, a sum such as a million dollars is written 
as $1,000,000.00 whereas in others it appears as $1.000.000,00 with point 
and comma interchanged. An early attempt at providing facilities for 
doing the right thing was fraught with complexity. So Ada 2012 has adopted 
the simple solution of enabling a program to determine the country code 
(two characters) and the language code (three characters) and then do 
its own thing. The codes are given by ISO standards. Canada is interesting 
in that it has one country code (<SPAN Class="swiss">&quot;CA&quot;</SPAN>) 
but uses two language codes (<SPAN Class="swiss">&quot;eng&quot;</SPAN> 
and <SPAN Class="swiss">&quot;fra&quot;</SPAN>).<A NAME="I1145"></A></div>
<div class="Normal">The information is provided by a new package <SPAN Class="swiss">Ada.Locales</SPAN> 
which declares the codes and the two functions <SPAN Class="swiss">Language</SPAN> 
and <SPAN Class="swiss">Country</SPAN> to return the current active locale 
(that is, the locale associated with the current task). <A NAME="I1146"></A><A NAME="I1147"></A></div>
<div class="Normal">And finally, we consider the container library. Containers 
were a major and very valuable addition to Ada 2005 but again, experience 
with use has indicated that some enhancements are necessary.</div>
<div class="Normal">We start with a brief summary of what is in Ada 2005. 
The parent package <SPAN Class="swiss">Ada.Containers</SPAN> has six 
main children namely <SPAN Class="swiss">Vectors</SPAN>, <SPAN Class="swiss">Doubly_Linked_Lists</SPAN>, 
<SPAN Class="swiss">Hashed_Maps</SPAN>, <SPAN Class="swiss">Ordered_Maps</SPAN>, 
<SPAN Class="swiss">Hashed_Sets</SPAN>, and <SPAN Class="swiss">Ordered_Sets</SPAN>. 
These manipulate definite types.</div>
<div class="Normal">In addition there are another six for manipulating 
indefinite types with names such as <SPAN Class="swiss">Indefinite_Vectors</SPAN> 
and so on.</div>
<div class="Normal">There are also two packages for sorting generic arrays, 
one for unconstrained types and one for constrained types.</div>
<div class="Normal" style="margin-bottom: 0.4em">There are four new 
kinds of containers in Ada 2012</div>
<div class="Bulleted">bounded forms of the existing containers,</div>
<div class="Bulleted">a container for a single indefinite object,</div>
<div class="Bulleted">various containers for multiway trees, and</div>
<div class="Bulleted">various containers for queues.&nbsp;</div>
<div class="Normal">In addition there are a number of auxiliary new facilities 
whose purpose is to simplify the use of containers.</div>
<div class="Normal">We will start by briefly looking at each of the new 
kinds of containers in turn.</div>
<div class="Normal">The existing containers are unbounded in the sense 
that there is no limit to the number of items that can be added to a 
list for example. The implementation is expected to use storage pools 
as necessary. However, many applications in high integrity and real-time 
areas forbid the use of access types and require a much more conservative 
approach. Accordingly, a range of containers is introduced with bounded 
capacity so that there is no need to acquire extra storage dynamically.</div>
<div class="Normal">Thus there are additional packages with names such 
as <SPAN Class="swiss">Containers.Bounded_Doubly_Linked_Lists</SPAN>. 
A key thing is that the types <SPAN Class="swiss">List</SPAN>, <SPAN Class="swiss">Vector</SPAN> 
and so on all have a discriminant giving their capacity thus <A NAME="I1148"></A></div>
<div class="SwissExamples"><B>type</B>&nbsp;List(Capacity:&nbsp;Count_Type)&nbsp;<B>is&nbsp;tagged&nbsp;private</B>;</div>
<div class="Normal" style="margin-bottom: 0.4em">so that when a container 
is declared its capacity is fixed. A number of consequential changes 
are made as well. For example, the bounded form has to have a procedure 
<SPAN Class="swiss">Assign</SPAN></div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Assign(Target:&nbsp;<B>in&nbsp;out</B>&nbsp;List;&nbsp;Source:&nbsp;<B>in</B>&nbsp;List);</div>
<div class="Normal">because using built-in assignment would raise <SPAN Class="swiss">Constraint_Error</SPAN> 
if the capacities were different. Using a procedure <SPAN Class="swiss">Assign</SPAN> 
means that the assignment will work provided the length of the source 
is not greater than the capacity of the target. If it is, the new exception 
<SPAN Class="swiss">Capacity_Error</SPAN> is raised.</div>
<div class="Normal">Moreover, a similar procedure <SPAN Class="swiss">Assign</SPAN> 
is added to all existing unbounded containers so that converting from 
a bounded to an unbounded container or vice versa is (reasonably) straightforward.</div>
<div class="Normal">A new function Copy is also needed for the bounded 
containers and for uniformity is similarly added to the unbounded versions.</div>
<div class="Normal">Conversion between bounded and unbounded containers 
is also guaranteed with respect to streaming.</div>
<div class="Normal">There are no bounded indefinite containers; this 
is because if the components are indefinite then dynamic space allocation 
is required for the components anyway and making the overall container 
bounded would be pointless.</div>
<div class="Normal">In Ada, it is not possible to declare an object of 
an indefinite type that can hold any value of the type. Thus if we declare 
an object of type <SPAN Class="swiss">String</SPAN> then it becomes constrained 
by the mandatory initial value.</div>
<div class="SwissExamples">S:&nbsp;String&nbsp;:=&nbsp;&quot;Crocodile&quot;;</div>
<div class="Normal">We can assign other strings to <SPAN Class="swiss">S</SPAN> 
but they must also have nine characters. We could assign <SPAN Class="swiss">&quot;Alligator&quot;</SPAN> 
but not <SPAN Class="swiss">&quot;Elephant&quot;</SPAN>. (An elephant 
is clearly too small!)</div>
<div class="Normal">This rigidity is rather a nuisance and so a new form 
of container is defined which enables the cunning declaration of an object 
of a definite type that can hold a single value of an indefinite type. 
In other words it is a wrapper. The new package is <SPAN Class="swiss">Ada.Containers.Indefinite_Holders</SPAN> 
and it takes a generic parameter of the indefinite type and declares 
a definite type <SPAN Class="swiss">Holder</SPAN> which is tagged private 
thus <A NAME="I1149"></A><A NAME="I1150"></A><A NAME="I1151"></A></div>
<div class="SwissExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Element_Type&nbsp;(&lt;&gt;)&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;&quot;=&quot;(Left,&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B>&nbsp;&lt;&gt;;<BR>
<B>package</B>&nbsp;Ada.Containers.Indefinite_Holders&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Holder&nbsp;<B>is&nbsp;tagged&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>various&nbsp;operations</I></SPAN><BR>
<B>end</B>&nbsp;Ada.Containers.Indefinite_Holders;</div>
<div class="Normal">The various operations include a procedure <SPAN Class="swiss">Replace_Element</SPAN> 
which puts a value into the holder and a function <SPAN Class="swiss">Element</SPAN> 
which returns the current value in the holder.</div>
<div class="Normal">Three new containers are added for multiway trees 
(unbounded, bounded, and indefinite). It might have been thought that 
it would be easy to use the existing containers (such as the list container) 
to create a tree structure. But it is difficult for various reasons concerning 
memory management. And so it was concluded that new containers for multiway 
trees should be added to Ada 2012. <A NAME="I1152"></A> <A NAME="I1153"></A></div>
<div class="Normal">The package <SPAN Class="swiss">Ada.Containers.Multiway_Trees</SPAN> 
is the unbounded form similar to the existing containers for other structures. 
It has all the operations required to operate on a tree structure where 
each node can have multiple child nodes to any depth. Thus there are 
operations on subtrees, the ability to find siblings, to insert and remove 
children and so on. The other new tree containers are <SPAN Class="swiss">Ada.Containers.Indefinite_Multiway_Trees</SPAN> 
and <SPAN Class="swiss">Ada.Containers.Bounded_Multiway_Trees</SPAN> 
which provide bounded and indefinite forms respectively. <A NAME="I1154"></A><A NAME="I1155"></A><A NAME="I1156"></A><A NAME="I1157"></A><A NAME="I1158"></A><A NAME="I1159"></A></div>
<div class="Normal">Finally, there is a group of containers for queues. 
This topic is particularly interesting because it has its origins in 
the desire to provide container operations that are task safe. However, 
it turned out that it was not easy to make the existing containers task 
safe in a general way which would satisfy all users because there are 
so many possibilities. <A NAME="I1160"></A></div>
<div class="Normal">However, there was no existing container for queues 
and in the case of queues it is easy to see how to make them task safe.</div>
<div class="Normal" style="margin-bottom: 0.4em">There are in fact four 
queue containers and all apply to queues where the element type is definite; 
these come in both bounded and unbounded forms and for synchronized and 
priority queues. We get (writing <SPAN Class="swiss">AC</SPAN> as an 
abbreviation for <SPAN Class="swiss">Ada.Containers</SPAN>)</div>
<div class="Bulleted"><SPAN Class="swiss">AC.Unbounded_Synchronized_Queues</SPAN>,</div>
<div class="Bulleted"><SPAN Class="swiss">AC.Bounded_Synchronized_Queues</SPAN>,</div>
<div class="Bulleted"><SPAN Class="swiss">AC.Unbounded_Priority_Queues</SPAN>,</div>
<div class="Bulleted"><SPAN Class="swiss">AC.Bounded_Priority_Queues</SPAN>. 
</div>
<div class="Normal" style="margin-bottom: 0.4em">These in turn are all 
derived from a single synchronized interface. This is a good illustration 
of the use of synchronized interfaces and especially the aspect <SPAN Class="swiss">Synchronization</SPAN> 
discussed earlier (see Section <A HREF="Rat12-1-3-4.html">1.3.4</A>). 
First there is the following generic package which declares the type 
<SPAN Class="swiss">Queue</SPAN> as a synchronized interface (writing 
<SPAN Class="swiss">AC</SPAN> as an abbreviation for <SPAN Class="swiss">Ada.Containers</SPAN> 
and <SPAN Class="swiss">ET</SPAN> for <SPAN Class="swiss">Element_Type</SPAN>) 
<A NAME="I1161"></A><A NAME="I1162"></A></div>
<div class="SwissExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;ET&nbsp;<B>is&nbsp;private</B>;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>element&nbsp;type&nbsp;for&nbsp;definite&nbsp;queues</I></SPAN><BR>
<B>package</B>&nbsp;AC.Synchronized_Queue_Interfaces&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Pure(...);<BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Queue&nbsp;<B>is&nbsp;synchronized&nbsp;interface</B>;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Enqueue<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Queue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New_Item:&nbsp;<B>in</B>&nbsp;ET)<B>is&nbsp;abstract</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;Synchronization&nbsp;=&gt;&nbsp;By_Entry;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Dequeue<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Queue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Element:&nbsp;<B>out</B>&nbsp;ET)&nbsp;<B>is&nbsp;abstract</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;Synchronization&nbsp;=&gt;&nbsp;By_Entry;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Current_Use(Container:&nbsp;Queue)&nbsp;<B>return</B>&nbsp;Count_Type&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Peak_Use(Container:&nbsp;Queue)&nbsp;<B>return</B>&nbsp;Count_Type&nbsp;<B>is&nbsp;abstract</B>;<BR>
<B>end</B>&nbsp;AC.Synchronized_Queue_Interfaces;</div>
<div class="Normal">Then there are generic packages which enable us to 
declare actual queues. Thus the essence of the unbounded synchronized 
version is as follows (still with abbreviations <SPAN Class="swiss">AC</SPAN> 
for <SPAN Class="swiss">Ada.Containers</SPAN>, <SPAN Class="swiss">ET</SPAN> 
for <SPAN Class="swiss">Element_Type</SPAN>) <A NAME="I1163"></A><A NAME="I1164"></A></div>
<div class="SwissExamples"><B>with</B>&nbsp;System;&nbsp;<B>use</B>&nbsp;System;<BR>
<B>with</B>&nbsp;AC.Synchronized_Queue_Interfaces;<BR>
<B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;<B>package</B>&nbsp;Queue_Interfaces<B>&nbsp;is&nbsp;new</B>&nbsp;AC.Synchronized_Queue_Interfaces(&lt;&gt;);<BR>
&nbsp;&nbsp;&nbsp;Default_Ceiling:&nbsp;Any_Priority&nbsp;:=&nbsp;Priority'Last;<BR>
<B>package</B>&nbsp;AC.Unbounded_Synchronized_Queues&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborate(...);</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;Implementation&nbsp;is<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>not&nbsp;specified&nbsp;by&nbsp;the&nbsp;language</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;Implementation;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>protected&nbsp;type</B>&nbsp;Queue(Ceiling:&nbsp;Any_Priority&nbsp;:=&nbsp;Default_Ceiling)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;Priority&nbsp;=&gt;&nbsp;Ceiling<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>is&nbsp;new</B>&nbsp;Queue_Interfaces.Queue&nbsp;<B>with</B></div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>overriding</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>entry</B>&nbsp;Enqueue(New_Item:&nbsp;<B>in</B>&nbsp;Queue_Interfaces.ET)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>overriding</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>entry</B>&nbsp;Dequeue(Element:&nbsp;<B>out</B>&nbsp;Queue_Interfaces.ET);</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>overriding</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Current_Use&nbsp;<B>return</B>&nbsp;Count_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>overriding</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Peak_Use&nbsp;<B>return</B>&nbsp;Count_Type;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;Queue;</div>
<div class="SwissExamples"><B>private</B><BR>
&nbsp;&nbsp;&nbsp;...<BR>
<B>end</B>&nbsp;AC.Unbounded_Synchronized_Queues;</div>
<div class="Normal">The discriminant gives the ceiling priority and for 
convenience has a default value. Remember that a protected type is limited 
and when used to implement an interface (as here) is considered to be 
tagged. In Ada 2012, defaults are allowed for discriminants of tagged 
types provided they are limited as mentioned in Section <A HREF="Rat12-1-3-3.html">1.3.3</A>.</div>
<div class="Normal">Note that the <SPAN Class="swiss">Priority</SPAN> 
is given by an aspect specification. Programmers who are allergic to 
the multiple uses of <B>with</B> could of course use the old pragma <SPAN Class="swiss">Priority</SPAN> 
in their own code.</div>
<div class="Normal">(The need for the package Implementation will be 
briefly explained in Section <A HREF="Rat12-8-6.html">8.6</A> and can 
be completely ignored by the user.)</div>
<div class="Normal" style="margin-bottom: 0.4em">Now to declare our 
own queue of integers say we first write</div>
<div class="SwissExamples"><B>package</B>&nbsp;My_Interface&nbsp;<B>is&nbsp;new</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;AC.Synchronized_Queue_Interfaces(ET&nbsp;=&gt;&nbsp;Integer);</div>
<div class="Normal" style="margin-bottom: 0.4em">This creates an interface 
for dealing with integers. Then to obtain an unbounded queue package 
for integers we write</div>
<div class="SwissExamples"><B>package</B>&nbsp;My_Q_Package&nbsp;<B>is&nbsp;new</B><BR>
&nbsp;&nbsp;AC.Unbounded_Synchronized_Queues(My_Interface);</div>
<div class="Normal" style="margin-bottom: 0.4em">This creates a package 
which declares a protected type <SPAN Class="swiss">Queue</SPAN>. Now 
at last we can declare an object of this type and perform operations 
on it.</div>
<div class="SwissExamples">The_Queue:&nbsp;My_Q_Package.Queue;<BR>
...<BR>
The_Queue.Enqueue(37);</div>
<div class="Normal">The various calls of <SPAN Class="swiss">Enqueue</SPAN> 
and <SPAN Class="swiss">Dequeue</SPAN> are likely to be in different 
tasks and the protected object ensures that all is well.</div>
<div class="Normal">The other generic queue packages follow a similar 
style. Note that unlike the other containers, there are no queue packages 
for indefinite types. Indefinite types can be catered for by using the 
holder container as a wrapper or by using an access type.</div>
<div class="Normal" style="margin-bottom: 0.4em">In Ada 2005 there are 
two generic procedures for sorting arrays; one is for constrained arrays 
and one is for unconstrained arrays. In Ada 2012, a third generic procedure 
is added which can be used to sort any indexable structure.<A NAME="I1165"></A> 
Its specification is</div>
<div class="SwissExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Index_Type&nbsp;<B>is</B>&nbsp;(&lt;&gt;);<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Before(Left,&nbsp;Right:&nbsp;Index_Type)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;procedure</B>&nbsp;Swap(Left,&nbsp;Right:&nbsp;Index_Type);<BR>
<B>procedure</B>&nbsp;Ada.Containers.Generic_Sort(First,&nbsp;Last:&nbsp;Index_Type'Base);<BR>
<B>pragma</B>&nbsp;Pure(Ada.Containers.Generic_Sort);</div>
<div class="Normal">Note that there is no parameter indicating the structure 
to be sorted; this is all done indirectly by the subprograms <SPAN Class="swiss">Before</SPAN> 
and <SPAN Class="swiss">Swap</SPAN> working over the range of values 
given by <SPAN Class="swiss">First</SPAN> and <SPAN Class="swiss">Last</SPAN>. 
It's almost magic!</div>
<div class="Normal">A frequent requirement when dealing with containers 
is the need to visit every node and perform some action, in other words 
to iterate over the container. And there are probably many different 
iterations to be performed. In Ada 2005, this has to be done by the user 
defining a subprogram for each iteration or writing out detailed loops 
involving calling <SPAN Class="swiss">Next</SPAN> and checking for the 
last element of the container and so on. And we have to write out this 
mechanism for each such iteration.</div>
<div class="Normal" style="margin-bottom: 0.4em">In Ada 2012, after 
some preparatory work involving the new package <SPAN Class="swiss">Ada.Iterator.Interfaces</SPAN> 
it is possible to simplify such iterations hugely. For example, suppose 
we have a list container each of whose elements is a record containing 
two components of type <SPAN Class="swiss">Integer</SPAN> (<SPAN Class="swiss">P</SPAN> 
and <SPAN Class="swiss">Q</SPAN> say) and we want to add some global 
<SPAN Class="swiss">X</SPAN> to <SPAN Class="swiss">Q</SPAN> for all 
elements where <SPAN Class="swiss">P</SPAN> is a prime.<A NAME="I1166"></A> 
In Ada 2005 we have to write the laborious</div>
<div class="SwissExamples">C&nbsp;:=&nbsp;The_List.First;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;C&nbsp;declared&nbsp;as&nbsp;of&nbsp;type&nbsp;Cursor</I></SPAN><BR>
<B>loop</B><BR>
&nbsp;&nbsp;&nbsp;<B>exit&nbsp;when</B>&nbsp;C&nbsp;=&nbsp;No_Element;<BR>
&nbsp;&nbsp;&nbsp;E&nbsp;:=&nbsp;Element(C);<BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;Is_Prime(E.P)&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace_Element(The_List,&nbsp;C,&nbsp;(E.P,&nbsp;E.Q&nbsp;+&nbsp;X));<BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;<BR>
&nbsp;&nbsp;&nbsp;C&nbsp;:=&nbsp;Next(C);<BR>
<B>end&nbsp;loop</B>;</div>
<div class="Normal" style="margin-bottom: 0.4em">Not only is this tedious 
but there is lots of scope for errors. However, in Ada 2012 we can simply 
write</div>
<div class="SwissExamples"><B>for</B>&nbsp;E&nbsp;<B>of</B>&nbsp;The_List&nbsp;<B>loop</B><BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;Is_Prime(E.P)&nbsp;<B>then</B>&nbsp;E.Q&nbsp;:=&nbsp;E.Q&nbsp;+&nbsp;X;&nbsp;<B>end&nbsp;if</B>;<BR>
<B>end&nbsp;loop</B>;</div>
<div class="Normal">The mechanism is thus similar to that introduced 
in the previous section for arrays.</div>
<div class="Normal">There are also a number of minor new facilities designed 
to simplify the use of containers. These include the introduction of 
case insensitive operations for comparing strings and for writing hash 
functions.</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="Rat12-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-0-3.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-1-3-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat12-1-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Class="Normal">&copy; 2011, 2012, 2013 John Barnes Informatics.</DIV>
<DIV Class="Normal">Sponsored in part by:</DIV>
<TABLE Summary="Sponsors" Width="800">
<TR><TD Width="250" Align="Center" VAlign="Top">
<SPAN Style="font-family: Arial, Helvetica, sans-serif; font-size: 92%">The <b><A HREF="http://www.adaic.org/community/">Ada Resource Association</A></b>:<BR><BR>
&nbsp;&nbsp;&nbsp; <A HREF="http://www.adaic.org"><IMG SRC="aralogo.gif" ALT="ARA" Height="120" Border="0"></A></SPAN>
</TD>
<TD Width="300" Align="Center" VAlign="Top">
<SPAN Style="font-family: Arial, Helvetica, sans-serif; font-size: 92%">&nbsp; <b><A HREF="http://www.adacore.com">AdaCore</A></b>:<BR><BR><BR>
&nbsp;&nbsp;&nbsp; <A HREF="http://www.adacore.com"><IMG SRC="adacore.gif" ALT="AdaCore" Height="80" Border="0"></A></SPAN>
</TD>
<TD Width="250" Align="Center" VAlign="Top">
<SPAN Style="font-family: Arial, Helvetica, sans-serif; font-size: 92%">and &nbsp; <b><A HREF="http://www.ada-europe.org">Ada-Europe</A></b>:<BR><BR>
<A HREF="http://www.ada-europe.org"><IMG SRC="AE_logo.gif" ALT="Ada-Europe" Height="128" Border="0"></A></SPAN>
</TD></TR>
</TABLE>
</BODY>
</HTML>
