<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Expressions</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-bottom: 0.6em}
    DIV.SwissExamples {font-family: Arial, Helvetica, sans-serif; font-size: 90%; line-height: 122%; margin-left: 2.2em; margin-bottom: 0.6em}
    DIV.Indented3MediumHanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 6.0em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Indented3MediumHanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 2.0em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<H1 Style='font-family: "Rockwell", "Times New Roman", Times, serif; font-size: 240%'><B><SPAN Style="color:rgb(0,0,153)">Rationale Update</SPAN> for <SPAN Style="color:rgb(0,153,51)">Ada 2012</SPAN></B></H1>
<DIV Class="Normal"><FONT SIZE="+1"><I><A HREF="RCorr-TTL.html">John Barnes</A></I></FONT></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="RCorr-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-0-2.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-0-1.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>Chapter 3: Expressions</H1>
<div class="Normal">The introduction of contracts triggered the need 
for more flexible forms of expressions in Ada 2012. These are conditional 
expressions (if and case), quantified expressions, and expression functions. 
In addition membership tests were made much more flexible.</div>
<div class="Normal" style="margin-bottom: 0.4em">The following Ada issues 
cover this area:</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0022-1.TXT">22</A>*</div><div class="Indented3MediumHanging-Body">
Raise expressions</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">39</A>*</div><div class="Indented3MediumHanging-Body">
Ambiguity in syntax for membership expression removed</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0040-1.TXT">40</A></div><div class="Indented3MediumHanging-Body">
Resolving the selected_expression of a case_expression</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0050-1.TXT">50</A></div><div class="Indented3MediumHanging-Body">
Conformance of quantified expressions</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0062-1.TXT">62</A></div><div class="Indented3MediumHanging-Body">
Raise expression with failing string function</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0084-1.TXT">84</A></div><div class="Indented3MediumHanging-Body">
Box expressions in array aggregates</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0100-1.TXT">100</A></div><div class="Indented3MediumHanging-Body">
A qualified expression makes a predicate check</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0103-1.TXT">103</A></div><div class="Indented3MediumHanging-Body">
Expression functions that are completions in package specifications</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0141-1.TXT">141</A></div><div class="Indented3MediumHanging-Body">
Add raise expression to Introduction</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0147-1.TXT">147</A></div><div class="Indented3MediumHanging-Body">
Expression functions and null procedures can be declared in a protected_body</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0152-1.TXT">152</A></div><div class="Indented3MediumHanging-Body">
Eliminate ambiguities in raise expression and derived type syntax</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0157-1.TXT">157</A></div><div class="Indented3MediumHanging-Body">
Missing rules for expression functions</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0158-1.TXT">158</A></div><div class="Indented3MediumHanging-Body">
Definition of quantified expressions</div>
<div class="Normal">These changes can be grouped as follows.</div>
<div class="Normal">The most important change in this update is perhaps 
the introduction of raise expressions (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0022-1.TXT">22</A>, 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0062-1.TXT">62</A>, 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0141-1.TXT">141</A>, 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0152-1.TXT">152</A>); 
it is convenient to discuss a change to the syntax for membership test 
at the same time (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">39</A>).</div>
<div class="Normal">A number of changes relate to expression functions 
(<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0103-1.TXT">103</A>, 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0147-1.TXT">147</A>, 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0157-1.TXT">157</A>). 
There are also some clarifications regarding quantified expressions (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0050-1.TXT">50</A>, 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0158-1.TXT">158</A>).</div>
<div class="Normal">There are miscellaneous changes to qualified expressions 
(<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0100-1.TXT">100</A>), 
case expressions (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0040-1.TXT">40</A>), 
and array aggregates (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0084-1.TXT">84</A>).</div>

<HR SIZE=1>

<div class="Normal">The introduction of raise expressions by <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0022-1.TXT">AI-22</A> 
was deemed important enough to be mentioned in the Introduction to the 
revised RM. It was discussed in some detail in the <A HREF="Rat12-9-5.html">Postscript
chapter 
of the Ada 2012 Rationale</A> which was written after the Ada 2012 standard 
was published. However, the discussion there needs updating since the 
syntax rules have been modified as a consequence of ambiguities mentioned 
in <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI-39</A> 
and <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0152-1.TXT">AI-152</A>. 
So here is a more integrated description.</div>
<div class="Normal" style="margin-bottom: 0.4em">The raise expression, 
is added by analogy with if statements and the raise statement. Thus 
as well as<A NAME="I1024"></A></div>
<div class="SwissExamples"><B>if</B>&nbsp;X&nbsp;&lt;&nbsp;Y&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;Z&nbsp;:=&nbsp;+1;<BR>
<B>elsif</B>&nbsp;X&nbsp;&gt;&nbsp;Y&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;Z&nbsp;:=&nbsp;&ndash;1;<BR>
<B>else</B><BR>
&nbsp;&nbsp;&nbsp;<B>raise</B>&nbsp;Error;<BR>
<B>end&nbsp;if</B>;</div>
<div class="Normal" style="margin-bottom: 0.4em">we can also write</div>
<div class="SwissExamples">Z&nbsp;:=&nbsp;(<B>if</B>&nbsp;X&lt;Y&nbsp;<B>then</B>&nbsp;1&nbsp;<B>elsif</B>&nbsp;X&gt;Y&nbsp;<B>then</B>&nbsp;&ndash;1&nbsp;<B>else&nbsp;raise</B>&nbsp;Error);</div>
<div class="Normal" style="margin-bottom: 0.4em">The syntax for raise 
expression is now as follows</div>
<div class="SwissExamples"><SPAN Class="swiss">raise_expression&nbsp;::=</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><B>raise</B></SPAN>&nbsp;<SPAN Class="roman"><I>exception</I></SPAN><SPAN Class="swiss">_name</SPAN>&nbsp;[<SPAN Class="roman"><B>with</B></SPAN>&nbsp;<SPAN Class="roman"><I>string</I></SPAN><SPAN Class="swiss">_simple_expression</SPAN>]</div>
<div class="Normal">Note that unlike in a raise statement, the string 
expression has to be a simple_expression rather than an expression in 
order to avoid ambiguities involving logical operations.</div>
<div class="Normal">A raise expression is a new form of <SPAN Class="swiss">relation</SPAN> 
(as will be seen in the syntax in a moment) and has the same precedence 
and so will need to be in parentheses in some contexts. But as illustrated 
above it does not need parentheses when used in a conditional expression 
which itself will have parentheses.</div>
<div class="Normal" style="margin-bottom: 0.4em">Raise expressions will 
be found useful with pre- and postconditions. Thus if we have</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Push(S:&nbsp;<B>in&nbsp;out</B>&nbsp;Stack;&nbsp;X:&nbsp;<B>in</B>&nbsp;Item)<BR>
&nbsp;&nbsp;&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pre&nbsp;=&gt;&nbsp;<B>not</B>&nbsp;Is_Full(S);</div>
<div class="Normal" style="margin-bottom: 0.4em">and the precondition 
is false then <SPAN Class="swiss">Assertion_Error</SPAN> is raised. But 
we can now alternatively write</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Push(S:&nbsp;<B>in&nbsp;out</B>&nbsp;Stack;&nbsp;X:&nbsp;<B>in</B>&nbsp;Item)<BR>
&nbsp;&nbsp;&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pre&nbsp;=&gt;&nbsp;<B>not</B>&nbsp;Is_Full(S)<B>&nbsp;or&nbsp;else&nbsp;raise</B>&nbsp;Stack_Error;</div>
<div class="Normal" style="margin-bottom: 0.4em">and of course we can 
also add a message thus</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pre&nbsp;=&gt;&nbsp;<B>not</B>&nbsp;Is_Full(S)&nbsp;<B>or&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise</B>&nbsp;Stack_Error&nbsp;<B>with</B>&nbsp;&quot;wretched&nbsp;stack&nbsp;is&nbsp;full&quot;;</div>
<div class="Normal">Another issue concerns what happens if the string 
expression in a raise expression (or indeed in a raise statement) itself 
raises an exception; it could be a function call which returns the string. 
The answer is that the one caused by the string expression is propagated 
instead of the one given in the raise expression or statement (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0062-1.TXT">AI-62</A>).</div>
<div class="Normal">On a closely related topic the syntax for membership 
tests has been found to cause ambiguities (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI-39</A>). 
<A NAME="I1025"></A></div>
<div class="Normal" style="margin-bottom: 0.4em">Thus</div>
<div class="SwissExamples">A&nbsp;<B>in</B>&nbsp;B&nbsp;<B>and</B>&nbsp;C</div>
<div class="Normal">could be interpreted as either of the following&nbsp;</div>
<div class="SwissExamples">(A&nbsp;<B>in</B>&nbsp;B)&nbsp;<B>and</B>&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>or</I></SPAN><BR>
A&nbsp;<B>in</B>&nbsp;(B&nbsp;<B>and</B>&nbsp;C)</div>
<div class="Normal" style="margin-bottom: 0.4em">This is cured by changing 
the syntax for <SPAN Class="swiss">relation</SPAN> to</div>
<div class="SwissExamples"><SPAN Class="swiss">relation&nbsp;::=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;simple_expression&nbsp;[relational_operator&nbsp;simple_expression]<BR>
&nbsp;&nbsp;|&nbsp;</SPAN><SPAN Class="roman"><I>tested</I></SPAN><SPAN Class="swiss">_simple_expression</SPAN>&nbsp;[<SPAN Class="roman"><B>not</B></SPAN>]&nbsp;<SPAN Class="roman"><B>in</B></SPAN>&nbsp;<SPAN Class="swiss">membership_choice_list<BR>
&nbsp;&nbsp;|&nbsp;raise_expression</SPAN></div>
<div class="Normal" style="margin-bottom: 0.4em">and changing membership 
choice to use <SPAN Class="swiss">simple_expression</SPAN> as well</div>
<div class="SwissExamples"><SPAN Class="swiss">membership_choice&nbsp;::=</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>choice</I></SPAN><SPAN Class="swiss">_simple_expression&nbsp;|&nbsp;range&nbsp;|&nbsp;subtype_mark</SPAN></div>
<div class="Normal">Thus a <SPAN Class="swiss">membership_choice</SPAN> 
no longer uses a <SPAN Class="swiss">choice_expression</SPAN>. However, 
the form <SPAN Class="swiss">choice_expression</SPAN> is still used in 
<SPAN Class="swiss">discrete_choice</SPAN>.</div>
<div class="Normal" style="margin-bottom: 0.4em">When first written, 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0022-1.TXT">AI-22</A> 
showed the syntax for a raise expression using <SPAN Class="roman"><I>string</I></SPAN><SPAN Class="swiss">_expression</SPAN> 
just as in raise statement. However, this caused ambiguities as mentioned 
earlier so it was changed to <I>string</I>_simple_expression by <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0152-1.TXT">AI-152</A>. 
Curiously enough it was also necessary to change the syntax of digits 
constraint and delta constraint to use simple expression as well. The 
AI has the following bizarre example</div>
<div class="SwissExamples">Atomic:&nbsp;String&nbsp;:=&nbsp;&quot;Gotcha&quot;;</div>
<div class="SwissExamples"><B>type</B>&nbsp;Fun&nbsp;<B>is&nbsp;new</B>&nbsp;My_Decimal_Type&nbsp;<B>digits</B><BR>
&nbsp;&nbsp;&nbsp;<B>raise</B>&nbsp;TBD_Error&nbsp;<B>with</B>&nbsp;Atomic;</div>
<div class="Normal" style="margin-bottom: 0.4em">This could be parsed 
as either</div>
<div class="SwissExamples"><B>type</B>&nbsp;Fun&nbsp;<B>is&nbsp;new</B>&nbsp;My_Decimal_Type&nbsp;<B>digits</B><BR>
&nbsp;&nbsp;&nbsp;(<B>raise</B>&nbsp;TBD_Error&nbsp;<B>with</B>&nbsp;Atomic);</div>
<div class="Normal" style="margin-bottom: 0.4em">or</div>
<div class="SwissExamples"><B>type</B>&nbsp;Fun&nbsp;<B>is&nbsp;new</B>&nbsp;My_Decimal_Type&nbsp;<B>digits</B><BR>
&nbsp;&nbsp;&nbsp;(<B>raise</B>&nbsp;TBD_Error)&nbsp;<B>with</B>&nbsp;Atomic;</div>
<div class="Normal" style="margin-bottom: 0.4em">So we now have</div>
<div class="SwissExamples"><SPAN Class="swiss">digits_constraint&nbsp;::=</SPAN><BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><B>digits</B>&nbsp;<I>static</I></SPAN><SPAN Class="swiss">_simple_expression&nbsp;[range_constraint]</SPAN><BR>
<SPAN Class="swiss">delta_constraint&nbsp;::=</SPAN><BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><B>delta</B>&nbsp;<I>static</I></SPAN><SPAN Class="swiss">_simple_expression&nbsp;[range_constraint]</SPAN></div>
<div class="Normal">It seems cruel to have to change delta constraint 
which one might have thought was peacefully buried in Annex J for obsolescent 
features.</div>
<div class="Normal">These potential ambiguities are unlikely to impact 
the normal user. If the compiler complains then the judicious insertion 
of some parentheses will undoubtedly cure the problem.</div>
<div class="Normal">Expression functions were added in Ada 2012. Remember 
that an expression function takes the form<A NAME="I1026"></A></div>
<div class="SwissExamples"><B>function</B>&nbsp;F&nbsp;(&nbsp;...&nbsp;)&nbsp;<B>return</B>&nbsp;T&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;(<SPAN Class="roman"><I>expression&nbsp;of&nbsp;subtype&nbsp;T</I></SPAN>);</div>
<div class="Normal" style="margin-bottom: 0.4em">A good example was 
given earlier thus</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Non_Zero(X:&nbsp;T)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(X&nbsp;/=&nbsp;0);</div>
<div class="Normal">Remember that such functions can act as a complete 
function or as a completion of a traditional function specification.</div>
<div class="Normal">A number of points were overlooked in the definition 
of Ada 2012. One has already been mentioned namely that function expressions 
acting as completions cannot have pre- and postconditions (see <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0105-1.TXT">AI-105</A> 
in Chapter <A HREF="RCorr-2.html">2</A>).</div>
<div class="Normal" style="margin-bottom: 0.4em">Another point is that 
expression functions and indeed null procedures can be used in the body 
of a protected type as a completion of a protected subprogram (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0147-1.TXT">AI-147</A>). 
This requires a modification to the syntax which becomes<A NAME="I1027"></A></div>
<div class="SwissExamples"><SPAN Class="swiss">protected_operation_item&nbsp;::=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;subprogram_declaration<BR>
&nbsp;&nbsp;|&nbsp;subprogram_body<BR>
&nbsp;&nbsp;|&nbsp;null_procedure_declaration<BR>
&nbsp;&nbsp;|&nbsp;expression_function_declaration<BR>
&nbsp;&nbsp;|&nbsp;entry_body<BR>
&nbsp;&nbsp;|&nbsp;aspect_clause</SPAN></div>
<div class="Normal" style="margin-bottom: 0.4em">An interesting situation 
arises if the result expression of an expression function can be written 
as an aggregate as for example</div>
<div class="SwissExamples"><B>function</B>&nbsp;Conjugate&nbsp;(C:&nbsp;Complex)&nbsp;<B>return</B>&nbsp;Complex&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;((C.Rl,&nbsp;&ndash;C.Im));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>double&nbsp;parens</I></SPAN></div>
<div class="Normal">Remember that the conjugate of a complex number <I>C</I> 
has the same real part but the imaginary part changes sign so that the 
conjugate point in the Argand plane is the reflection of <I>C</I> in 
the real axis.</div>
<div class="Normal" style="margin-bottom: 0.4em">The original rules 
say that the expression of an expression function is simply an expression 
in parentheses. However, this is ugly if the expression already has parentheses 
as occurs with an aggregate as above. Now Ada dislikes double parentheses 
so we have rules for if expressions that they have to be in parentheses 
unless the context already supplies parentheses as in the case of a subprogram 
call with a single parameter. Consequently, <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0157-1.TXT">AI-157</A> 
concludes that the second lot of parentheses are unnecessary so we can 
just write</div>
<div class="SwissExamples"><B>function</B>&nbsp;Conjugate&nbsp;(C:&nbsp;Complex)&nbsp;<B>return</B>&nbsp;Complex&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;(C.Rl,&nbsp;&ndash;C.Im);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>single&nbsp;parens</I></SPAN></div>
<div class="Normal" style="margin-bottom: 0.4em">As a result the syntax 
is revised to</div>
<div class="SwissExamples"><SPAN Class="swiss">expression_function_declaration&nbsp;::=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;[overriding&nbsp;_indicator]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;function_specification</SPAN>&nbsp;<SPAN Class="roman"><B>is</B></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="swiss">(expression)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[aspect_specification]&nbsp;;<BR>
&nbsp;&nbsp;|&nbsp;[overriding&nbsp;_indicator]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;function_specification</SPAN>&nbsp;<SPAN Class="roman"><B>is</B></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="swiss">aggregate<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[aspect_specification]&nbsp;;</SPAN></div>
<div class="Normal" style="margin-bottom: 0.4em">The above example shows 
a record aggregate. The same applies to array aggregates in parentheses. 
But of course if the result is given as a string then the parentheses 
are necessary. So we can have either of</div>
<div class="SwissExamples"><B>function</B>&nbsp;Piggy&nbsp;<B>return</B>&nbsp;String&nbsp;<B>is</B>&nbsp;('P',&nbsp;'I',&nbsp;'G');</div>
<div class="SwissExamples"><B>function</B>&nbsp;Piggy&nbsp;<B>return</B>&nbsp;String&nbsp;<B>is</B>&nbsp;(&quot;PIG&quot;);</div>
<div class="Normal">There are also changes to the freezing rules which 
will probably leave the reader cold. These are in <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0157-1.TXT">AI-157</A> 
and <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0103-1.TXT">AI-103</A>. 
A simple one is that expression functions acting as completions only 
freeze the expression and nothing else and null procedures never freeze 
anything.</div>
<div class="Normal">There are a couple of minor points regarding quantified 
expressions.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0158-1.TXT">AI-158</A> 
clarifies the result of a quantified expression where the array concerned 
has zero elements. In the case of the existential qualifier <B>for some</B>, 
the result is <SPAN Class="swiss">False</SPAN> whereas in the case of 
the universal qualifier <B>for all</B>, the result is <SPAN Class="swiss">True</SPAN>. 
So consider</div>
<div class="SwissExamples">B&nbsp;:=&nbsp;(<B>for&nbsp;all</B>&nbsp;K&nbsp;<B>in</B>&nbsp;A'Range&nbsp;=&gt;&nbsp;A(K)&nbsp;=&nbsp;0);</div>
<div class="Normal" style="margin-bottom: 0.4em">which assigns true 
to <SPAN Class="swiss">B</SPAN> if every element of <SPAN Class="swiss">A</SPAN> 
is zero. If <SPAN Class="swiss">A</SPAN> doesn't have any elements then 
the result is still true. Similarly</div>
<div class="SwissExamples">B&nbsp;:=&nbsp;(<B>for&nbsp;some</B>&nbsp;K&nbsp;<B>in</B>&nbsp;A'Range&nbsp;=&gt;&nbsp;A(K)&nbsp;=&nbsp;0);</div>
<div class="Normal">assigns true to <SPAN Class="swiss">B</SPAN> provided 
at least one element of <SPAN Class="swiss">A</SPAN> is zero. If <SPAN Class="swiss">A</SPAN> 
doesn't have any elements then the answer is false. This all seems pretty 
obvious but the wording was deemed to require clarification for those 
not having a Fields Medal in mathematics.</div>
<div class="Normal" style="margin-bottom: 0.4em">Another quirk is discussed 
by AI-50 which is concerned with conformance. Remember that the parameters 
in the specification and body of a subprogram have to conform. The introduction 
of quantified expressions means that such an expression could occur as 
the default value in a subprogram specification; thus using the example 
above we might have</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;P(B&nbsp;:&nbsp;Boolean&nbsp;:=<BR>
&nbsp;&nbsp;&nbsp;(<B>for&nbsp;all</B>&nbsp;K&nbsp;<B>in</B>&nbsp;A'Range&nbsp;=&gt;&nbsp;A(K)&nbsp;=&nbsp;0));</div>
<div class="Normal">The corresponding text in the procedure body has 
to conform and additional rules are required to ensure this. The new 
thing is that quantified expressions introduce declarations such as that 
of <SPAN Class="swiss">K</SPAN> in the parameter list and we have to 
say that these two (technically different) declarations are the same 
in specification and body and specifically that the two defining identifiers 
are the same and are used in the same way.</div>
<div class="Normal">A minor omission concerns qualified expressions (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0100-1.TXT">AI-100</A>) 
Remember the difference between a qualified expression and a conversion. 
Qualification (which takes a quote) just states that an expression has 
the given (sub)type and is often used for resolving ambiguities. Conversion 
(which does not have a quote) actually changes the type (if necessary). 
Qualification also checks any relevant subtype properties. But on the 
addition of subtype predicates although it was added that they were checked 
on type conversions, it was forgotten to add that any subtype predicates 
should also be checked on qualification.</div>
<div class="Normal">A very minor omission is covered by <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0040-1.TXT">AI-40</A> 
which says that case expressions and case statements resolve in exactly 
the same way &mdash; that is have the same rules for type matching.</div>
<div class="Normal">Finally, <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0084-1.TXT">AI-84</A> 
concerns the use of the box notation <SPAN Class="swiss">&lt;&gt;</SPAN> 
in array aggregates. This was added in Ada 2005 and indicates that a 
component takes its default value which is the same as the default value 
for a stand-alone object.</div>
<div class="Normal" style="margin-bottom: 0.4em">However, Ada 2012 added 
the aspects <SPAN Class="swiss">Default_Value</SPAN> and <SPAN Class="swiss">Default_Component_Value</SPAN>. 
So we might write <A NAME="I1028"></A><A NAME="I1029"></A><A NAME="I1030"></A><A NAME="I1031"></A></div>
<div class="SwissExamples"><B>type</B>&nbsp;My_Integer&nbsp;<B>is&nbsp;new</B>&nbsp;Integer<BR>
&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;Default_Value&nbsp;=&gt;&nbsp;999;</div>
<div class="SwissExamples"><B>type</B>&nbsp;My_Array&nbsp;<B>is&nbsp;array</B>&nbsp;(Integer&nbsp;<B>range</B>&nbsp;&lt;&gt;)&nbsp;<B>of</B>&nbsp;My_Integer<BR>
&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;Default_Component_Value&nbsp;=&gt;&nbsp;666;</div>
<div class="Normal" style="margin-bottom: 0.4em">If we declare</div>
<div class="SwissExamples">X:&nbsp;My_Array(1&nbsp;..&nbsp;10);</div>
<div class="Normal">then the value of <SPAN Class="swiss">X(1)</SPAN> 
will be 666 of course using the aspect <SPAN Class="swiss">Default_Component_Value</SPAN>.</div>
<div class="Normal" style="margin-bottom: 0.4em">But if we write</div>
<div class="SwissExamples">X:&nbsp;My_Array(1..10)&nbsp;:=&nbsp;(<B>others</B>&nbsp;=&gt;&nbsp;&lt;&gt;);</div>
<div class="Normal">then very surprisingly <SPAN Class="swiss">X(1)</SPAN> 
was 999 rather than 666. The rules for <SPAN Class="swiss">&lt;&gt;</SPAN> 
were not updated to note that if the <SPAN Class="swiss">Default_Component_Value</SPAN> 
has been given then that applies rather than the stand-alone value. This 
is put right by <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0084-1.TXT">AI-84</A> 
so that the value is now 666 in both cases.</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="RCorr-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-0-2.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-0-1.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Class="Normal">&copy; 2016 John Barnes Informatics.</DIV>
</BODY>
</HTML>
