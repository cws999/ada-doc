<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Structure and visibility</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-bottom: 0.6em}
    DIV.SwissExamples {font-family: Arial, Helvetica, sans-serif; font-size: 90%; line-height: 122%; margin-left: 2.2em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.Indented3MediumHanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 6.0em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Indented3MediumHanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 2.0em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<H1 Style='font-family: "Rockwell", "Times New Roman", Times, serif; font-size: 240%'><B><SPAN Style="color:rgb(0,0,153)">Rationale Update</SPAN> for <SPAN Style="color:rgb(0,153,51)">Ada 2012</SPAN></B></H1>
<DIV Class="Normal"><FONT SIZE="+1"><I><A HREF="RCorr-TTL.html">John Barnes</A></I></FONT></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="RCorr-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-0-2.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-0-1.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>Chapter 4: Structure and visibility</H1>
<div class="Normal">One of the most dramatic changes in Ada 2012 concerns 
subprogram parameters and is that functions can have parameters of all 
modes. Other areas covered here include incomplete types and discriminants.</div>
<div class="Normal" style="margin-bottom: 0.4em">The following Ada Issues 
cover this area:</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0065-1.TXT">65</A></div><div class="Indented3MediumHanging-Body">
Descendants of incomplete views</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0074-1.TXT">74</A></div><div class="Indented3MediumHanging-Body">
View conversions and out parameters passed by copy</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0094-1.TXT">94</A></div><div class="Indented3MediumHanging-Body">
An access definition should be a declarative region</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0095-1.TXT">95</A></div><div class="Indented3MediumHanging-Body">
Generic formal types and constrained partial views</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0097-1.TXT">97</A></div><div class="Indented3MediumHanging-Body">
Tag of the return object of a simple return expression</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0101-1.TXT">101</A></div><div class="Indented3MediumHanging-Body">
Incompatibility of hidden untagged record equality</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0109-1.TXT">109</A></div><div class="Indented3MediumHanging-Body">
Representation of untagged derived types</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0132-1.TXT">132</A></div><div class="Indented3MediumHanging-Body">
Freezing of renames-as-body</div>
<div class="Indented3MediumHanging-Term"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0137-1.TXT">137</A></div><div class="Indented3MediumHanging-Body">
Incomplete views and access to class wide types</div>
<div class="Normal">These changes can be grouped as follows.</div>
<div class="Normal">A number of issues concern views. There are clarifications 
of incomplete views (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0065-1.TXT">65</A>, 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0137-1.TXT">137</A>) 
and omissions concerning view conversions (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0074-1.TXT">74</A>) 
and constrained views (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0095-1.TXT">95</A>).</div>
<div class="Normal">An amusing issue concerns the definition of a declarative 
region (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0094-1.TXT">94</A>).</div>
<div class="Normal">Miscellaneous issues concern renaming (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0132-1.TXT">132</A>), 
untagged record equality (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0101-1.TXT">101</A>), 
untagged derived types (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0109-1.TXT">109</A>), 
and the tag of return objects (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0097-1.TXT">97</A>).</div>

<HR SIZE=1>

<div class="Normal" style="margin-bottom: 0.4em">A curious situation 
is discussed by <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0065-1.TXT">AI-65</A>. 
A type <SPAN Class="swiss">T3</SPAN> can be a descendant of <SPAN Class="swiss">T1</SPAN> 
but nevertheless inherits no characteristics of <SPAN Class="swiss">T1</SPAN> 
because of an intervening type <SPAN Class="swiss">T2</SPAN>. Consider</div>
<div class="SwissExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>private</B>;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>partial&nbsp;view</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;C:&nbsp;<B>constant</B>:&nbsp;T1;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is&nbsp;new</B>&nbsp;Integer;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>complete&nbsp;view</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;C:&nbsp;<B>constant</B>&nbsp;:=&nbsp;37;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>my&nbsp;favourite&nbsp;number</I></SPAN><BR>
<B>end</B>&nbsp;P;</div>
<div class="SwissExamples"><B>with</B>&nbsp;P;<BR>
<B>package</B>&nbsp;Q&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is&nbsp;new</B>&nbsp;P.T1;<BR>
<B>end</B>&nbsp;Q;</div>
<div class="SwissExamples"><B>with</B>&nbsp;Q;<BR>
<B>package</B>&nbsp;P.Child&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T3&nbsp;<B>is&nbsp;new</B>&nbsp;Q.T2;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>what&nbsp;can&nbsp;we&nbsp;do&nbsp;with&nbsp;T3&nbsp;here?</I></SPAN><BR>
<B>end</B>&nbsp;P.Chlld;</div>
<div class="Normal">In this example <SPAN Class="swiss">T3</SPAN> is 
derived from <SPAN Class="swiss">T2</SPAN> and <SPAN Class="swiss">T2</SPAN> 
is derived from <SPAN Class="swiss">T1</SPAN>. The fact that <SPAN Class="swiss">T2</SPAN> 
is derived from <SPAN Class="swiss">Integer</SPAN> is not visible to 
the declaration of <SPAN Class="swiss">T3</SPAN>. Nevertheless the conversion 
rules allow a value of type <SPAN Class="swiss">T1</SPAN> to be converted 
to <SPAN Class="swiss">T3</SPAN> in the private part of the child package. 
But the fact that <SPAN Class="swiss">T3</SPAN> is an integer type is 
not visible.</div>
<div class="Normal">We say that <SPAN Class="swiss">T3</SPAN> is effectively 
a descendant of an incomplete view of <SPAN Class="swiss">T1</SPAN>. 
(Note &quot;effectively&quot;; it's not technically an incomplete view 
but behaves in some ways as if it were.) So we can convert <SPAN Class="swiss">C</SPAN> 
but not <SPAN Class="swiss">73</SPAN> to type <SPAN Class="swiss">T3</SPAN> 
in the private part of <SPAN Class="swiss">C.Child</SPAN>.</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;X:&nbsp;T3&nbsp;:=&nbsp;T3(P.C)&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>OK</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;Y:&nbsp;T3&nbsp;:=&nbsp;T3(73);&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>No,&nbsp;T3&nbsp;is&nbsp;not&nbsp;visibly&nbsp;numeric!</I></SPAN></div>
<div class="Normal">It was meant to be like this in Ada 95; Ada 2005 
meddled with it and Ada 2012 made a confusing &quot;improvement&quot;. 
Hopefully the clarifications made now will be the end of the story.</div>
<div class="Normal">It is helpful to remember the distinction between 
a partial view and an incomplete view.</div>
<div class="Bulleted">A partial view is the view given by a private type 
declaration in contrast to the full view given by the full declaration 
in the private part. As in type <SPAN Class="swiss">T1</SPAN> above.<A NAME="I1032"></A></div>
<div class="Bulleted" style="margin-bottom: 0.3em">An incomplete view 
is the view given by an incomplete declaration such as occurs with access 
types. Thus<A NAME="I1033"></A></div>
<div class="SwissExamples"><B>type</B>&nbsp;Cell;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>incomplete&nbsp;view</I></SPAN><BR>
<B>type</B>&nbsp;Link&nbsp;<B>is</B>&nbsp;<B>access</B>&nbsp;Cell:<BR>
<BR>
<B>type</B>&nbsp;Cell&nbsp;<B>is</B>&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>completion</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Next:&nbsp;Link;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;record</B>;</div>
<div class="Normal">The use of the concept of incomplete views was much 
extended in Ada 2005 by the introduction of the limited with clause. 
It was extended again in Ada 2012 by allowing incomplete types to be 
completed by types other than access types and allowing incomplete views 
as parameters.</div>
<div class="Normal">There are many rules concerning access types that 
designate incomplete views. <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0137-1.TXT">AI-137</A> 
clarifies that they also apply to access to class wide types.</div>
<div class="Normal"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0095-1.TXT">AI-95</A> 
concerns an omission/confusion with regard to generic untagged formal 
types and partial views. Briefly, within a generic body we assume the 
worst as to whether or not a formal subtype has a constrained partial 
view. In particular we assume that untagged formal private and derived 
types do indeed have a constrained partial view.</div>
<div class="Normal" style="margin-bottom: 0.4em">As Ada has grown there 
have been further lexical amusements such as functions returning access 
to functions. Thus we can now have</div>
<div class="SwissExamples"><B>type</B>&nbsp;T&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>access&nbsp;function</B>(&nbsp;...&nbsp;)&nbsp;<B>return</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>access&nbsp;function</B>(&nbsp;...&nbsp;)&nbsp;<B>return</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>access&nbsp;function</B>(&nbsp;...&nbsp;)&nbsp;<B>return</B>&nbsp;...</div>
<div class="Normal" style="margin-bottom: 0.4em">ad infinitum. To be 
more specific the rules seem to prohibit</div>
<div class="SwissExamples"><B>type</B>&nbsp;T&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>access</B>&nbsp;<B>function</B>(A:&nbsp;Integer)&nbsp;<B>return</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>access</B>&nbsp;<B>function</B>(A:&nbsp;Float)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="Normal">because here we have two instances of <SPAN Class="swiss">A</SPAN> 
in the declarative region for <SPAN Class="swiss">T</SPAN>. There is 
no real reason why this should not be permitted so the definition of 
declarative region is extended to include an access definition (<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0094-1.TXT">AI-94</A>).<A NAME="I1034"></A></div>
<div class="Normal" style="margin-bottom: 0.4em">A somewhat different 
topic is addressed by <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0074-1.TXT">AI-74</A> 
and concerns parameters of mode <B>out</B> which have always been the 
source of troubles. The basic problem is that such parameters can become 
undefined. Consider this simple procedure to find the two roots of a 
quadratic equation</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Quadratic(A,&nbsp;B,&nbsp;C:&nbsp;<B>in</B>&nbsp;Real;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Root_1,&nbsp;Root_2:&nbsp;<B>out</B>&nbsp;Real;&nbsp;OK:&nbsp;<B>out</B>&nbsp;Boolean)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;D:&nbsp;<B>constant</B>&nbsp;Real&nbsp;:=&nbsp;B**2&nbsp;&ndash;&nbsp;4.0*A*C;<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;D&nbsp;&lt;&nbsp;0.0&nbsp;<B>or</B>&nbsp;A&nbsp;=&nbsp;0.0&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK&nbsp;:=&nbsp;False;&nbsp;<B>return</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;<BR>
&nbsp;&nbsp;&nbsp;Root_1&nbsp;:=&nbsp;(&ndash;B&nbsp;+&nbsp;Sqrt(D))&nbsp;/&nbsp;(2.0*A);<BR>
&nbsp;&nbsp;&nbsp;Root_2&nbsp;:=&nbsp;(&ndash;B&nbsp;&ndash;&nbsp;Sqrt(D))&nbsp;/&nbsp;(2.0*A);<BR>
&nbsp;&nbsp;&nbsp;OK&nbsp;:=&nbsp;True;<BR>
<B>end</B>&nbsp;Quadratic;</div>
<div class="Normal" style="margin-bottom: 0.4em">If the equation has 
complex roots then no values are assigned to <SPAN Class="swiss">Root_1</SPAN> 
and <SPAN Class="swiss">Root_2</SPAN> so they are likely to contain rubbish. 
So if we call <SPAN Class="swiss">Quadratic</SPAN> thus</div>
<div class="SwissExamples">Quadratic(AA,&nbsp;BB,&nbsp;CC,&nbsp;R1,&nbsp;R2,&nbsp;State);</div>
<div class="Normal">then because of the copy in and out rules for parameters 
of elementary types, the variables <SPAN Class="swiss">R1</SPAN> and 
<SPAN Class="swiss">R2</SPAN> which might have had respectable values 
will now contain rubbish.<A NAME="I1035"></A></div>
<div class="Normal">Of course if we had made the parameters <SPAN Class="swiss">Root_1</SPAN> 
and <SPAN Class="swiss">Root_2</SPAN> of mode <B>in out</B> then the 
original values of <SPAN Class="swiss">R1</SPAN> and <SPAN Class="swiss">R2</SPAN> 
would have been retained if no assignments were made to <SPAN Class="swiss">Root_1</SPAN> 
and <SPAN Class="swiss">Root_2</SPAN>.</div>
<div class="Normal">However, if we had been wise and used the <SPAN Class="swiss">Default_Value</SPAN> 
aspect introduced in Ada 2012 thus <A NAME="I1036"></A><A NAME="I1037"></A></div>
<div class="SwissExamples"><B>type</B>&nbsp;Real&nbsp;<B>is&nbsp;new</B>&nbsp;Float<BR>
&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;Default_Value&nbsp;:=&nbsp;0.0;</div>
<div class="Normal">then the behaviour is different. In this case <SPAN Class="swiss">Root_1</SPAN> 
and <SPAN Class="swiss">Root_2</SPAN> will behave essentially as if they 
were of mode <B>in out</B> and will remain unchanged. Note carefully 
that they will not take the default values of <SPAN Class="swiss">0.0</SPAN> 
and so the existing values of <SPAN Class="swiss">R1</SPAN> and <SPAN Class="swiss">R2</SPAN> 
will not be disturbed. Of course if we had declared a local variable 
<SPAN Class="swiss">R_Temp</SPAN> of type <SPAN Class="swiss">Real</SPAN> 
then it would take the initial value of 0.0.</div>
<div class="Normal">This technique of initially copying in parameters 
of mode <B>out</B> has existed in Ada for access types since Ada 83. 
Remember that access types always have a default initial value of <B>null</B> 
and so this copying in behaviour is identical. Incidentally, this copying 
in is done &quot;in the raw&quot; without making any subtype checks such 
as range constraints; again this follows the behaviour of access types. 
Note also that the whole purpose of an <B>out</B> parameter is to give 
it some value without concern for the original value of the actual parameter 
and so gratuitously checking the original value of the actual could be 
irritating if it raised an exception. Another point is that the default 
value applies to the type and not to the subtype.</div>
<div class="Normal">However, do remember that we cannot give a default 
value to the predefined types such as <SPAN Class="swiss">Float</SPAN> 
so this is a good reason for declaring our own types.</div>
<div class="Normal" style="margin-bottom: 0.4em">Other problems arise 
when an actual parameter is a view conversion and this is the real topic 
of <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0074-1.TXT">AI-74</A>. 
Consider the following simple example</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Inc(X:&nbsp;<B>in&nbsp;out</B>&nbsp;Integer)&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;X&nbsp;:=&nbsp;X&nbsp;+&nbsp;1;<BR>
<B>end</B>&nbsp;Inc;<BR>
...<BR>
F:&nbsp;Float;<BR>
...<BR>
F&nbsp;:=&nbsp;3.14;<BR>
Inc(Integer(F));</div>
<div class="Normal">Remember that the behaviour is that the value of 
<SPAN Class="swiss">F</SPAN> is converted to type <SPAN Class="swiss">Integer</SPAN> 
(and thus becomes <SPAN Class="swiss">3</SPAN>) and this is the initial 
value of the parameter <SPAN Class="swiss">X</SPAN> which is then incremented 
to <SPAN Class="swiss">4</SPAN> and finally converted to <SPAN Class="swiss">4.0</SPAN> 
and copied back into <SPAN Class="swiss">F</SPAN>. This is as in Ada 
83.</div>
<div class="Normal" style="margin-bottom: 0.4em">But problems arise 
if the parameter is an <B>out</B> parameter and not an <B>in out</B> 
parameter. Consider</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;P(X:&nbsp;<B>out</B>&nbsp;My_Integer)&nbsp;is&nbsp;...<BR>
...<BR>
Y:&nbsp;Long_Float&nbsp;:=&nbsp;1.0E20;<BR>
...<BR>
P(My_Integer(Y));</div>
<div class="Normal">Now suppose we have given <SPAN Class="swiss">Default_Value</SPAN> 
for <SPAN Class="swiss">My_Integer</SPAN>. An important goal of <SPAN Class="swiss">Default_Value</SPAN> 
is to ensure that junk values do not arise. This is done by treating 
<B>out</B> parameters essentially as <B>in out</B> parameters as illustrated 
by <SPAN Class="swiss">Quadratic</SPAN>. But now we are in trouble because 
we are unlikely to be able to convert the giant floating value <SPAN Class="swiss">Y</SPAN> 
to the type <SPAN Class="swiss">My_Integer</SPAN>.</div>
<div class="Normal">This problem is overcome by saying that if the aspect 
<SPAN Class="swiss">Default_Value</SPAN> is given for the type of the 
formal parameter then there must be an ancestor of both the target type 
and the operand type of the view conversion and the operand type itself 
must also have the aspect <SPAN Class="swiss">Default_Value</SPAN>. If 
the conversion meets these requirements, then it is bound to work. Otherwise, 
the view conversion (such as the example above) is made illegal.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0132-1.TXT">AI-132</A> 
concerns expression functions and freezing again (see the brief mention 
of <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0103-1.TXT">AI-103</A> 
in the previous Chapter). If we have an expression function such as<A NAME="I1038"></A></div>
<div class="SwissExamples"><B>function</B>&nbsp;F(...)&nbsp;<B>return</B>&nbsp;T&nbsp;is<BR>
&nbsp;&nbsp;&nbsp;(<I>expression&nbsp;of&nbsp;subtype&nbsp;T</I>);</div>
<div class="Normal" style="margin-bottom: 0.4em">then it can occur in 
a renaming as body thus</div>
<div class="SwissExamples"><B>function</B>&nbsp;G(&nbsp;...&nbsp;)&nbsp;<B>return</B>&nbsp;T&nbsp;<B>renames</B>&nbsp;F;</div>
<div class="Normal">This AI points out that this renaming freezes the 
expression of the expression function <SPAN Class="swiss">F</SPAN>.</div>
<div class="Normal" style="margin-bottom: 0.4em">The redefining of equality 
has always been a bother. Originally there were different rules for composition 
of tagged and untagged types. The difference was removed in Ada 2012 
in order to make composition more uniform. However, a quirk in the rules 
meant that a hidden definition of equality for an untagged record type 
as in<A NAME="I1039"></A><A NAME="I1040"></A></div>
<div class="SwissExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;PT&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;PT&nbsp;<B>is</B>&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>untagged</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;&quot;=&quot;&nbsp;(L,&nbsp;R:&nbsp;PT)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>end</B>&nbsp;P;</div>
<div class="Normal">was not permitted. This was a mistake and accordingly 
this restriction is removed by <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0132-1.TXT">AI-132</A>.</div>
<div class="Normal">There are omissions regarding aspect specifications 
and derived types. One of the advantages of the introduction of aspect 
specifications is that they occur with the entity to which they apply. 
This means that the traditional linear elaboration does not always apply 
because the aspect might refer to things that have not yet been declared. 
<A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0109-1.TXT">AI-109</A> 
clarifies the situation with regard to the freezing of the representation 
of untagged types.</div>
<div class="Normal" style="margin-bottom: 0.4em">Finally, <A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0097-1.TXT">AI-97</A> 
addresses a minor error in the description of the tag of an object in 
a return statement. The introduction of the extended return statement 
where we have</div>
<div class="SwissExamples"><B>return</B>&nbsp;R:&nbsp;T&nbsp;<B>do</B><BR>
&nbsp;&nbsp;&nbsp;...<BR>
<B>end</B>&nbsp;<B>return</B>;</div>
<div class="Normal">needed clarification because <SPAN Class="swiss">T</SPAN> 
might not be identical to the return type given in the function specification 
(it might be a subtype; perhaps the function has an indefinite type and 
the return is definite, perhaps classwide and specific and so on.) So 
the rules were rewritten to cover the extended return. Unfortunately 
the rules were written in a way that was incorrect for an old-fashioned 
return statement. This is now put right.</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="RCorr-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-0-2.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-0-1.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RCorr-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Class="Normal">&copy; 2016 John Barnes Informatics.</DIV>
</BODY>
</HTML>
